---
layout: post
title:  "Elixir's Advantage in the Era of AI"
date:   2025-03-15 10:00:00 -0500
categories: blog
tags: [elixir, phoenix, liveview, ai, cursor, claude-code]
author: Aaron
author_twitter: shamshirz
image: /assets/elixir-logo.jpeg
links: ["https://www.cursor.com/", "https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview", "https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)", "https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html", "https://hexdocs.pm/elixir/gradual-set-theoretic-types.html"]
---
My experience with AI-assisted coding [![elixir logo]({{ "/assets/elixir-logo.jpeg" | relative_url }}){:class="excerpt-image" style="border-radius: 8px; width: 80px; height: auto;"}](https://elixir-lang.org/) {%- if page.tags -%}{% for tag in page.tags %}<a href="{{site.baseurl}}/archive.html#{{tag | slugize}}">#{{ tag }}</a> {% endfor %}{%- endif -%}
<!-- Ends the excerpt text, it includes the image -->

I‚Äôve been deep in AI dev tooling for about 10 months, and I‚Äôm now fully bought in on the future of AI-assisted development. Tools like Cursor and Claude Code are no longer just autocomplete‚Äîthey can self-iterate. They‚Äôll run tests, interpret failures, and revise code without my intervention, and do it until everything works.

And the more structured feedback you feed these tools‚Äîerrors, types, docs, tests‚Äîthe better they perform. We want to make each iteration as fast and accurate as possible. That‚Äôs where Elixir quietly shines.

Despite being a small slice of training data, Elixir is uniquely well-positioned to thrive in this new model. **It‚Äôs a composition of three traits that stack up beautifully for AI pair programming: First-Class Documentation, Functional + Compiled Design, and a Deeply Integrated Testing Model (thanks, BEAM).** Here's why.

## 1. First-Class Documentation: Context Built into the Code

Elixir treats documentation as a first-class citizen. Every function and module has structured, built-in documentation that lives right next to the code. It‚Äôs not just scattered comments‚Äîit‚Äôs compiled, queryable, and often includes real usage examples through doctests. That can be run and updated by our AI!

This is a goldmine for LLMs. Instead of guessing how a function works, AI tools can read structured descriptions, see example inputs/outputs, and even run the embedded tests. This means fewer hallucinations, better API usage, and more accurate code. Elixir isn‚Äôt alone‚Äîbut it stands out.

## 2. Functional & Compiled: Predictable, Debuggable, and AI-Friendly

Grouping these may be cheating, but any functional, compiled language has an edge for AI. Functional code is easier to reason about for people because you should only need the context of the function you are in. No side-effects on variables outside the scope, no class variables to chase down, and the AI's context window thanks you. Elixir is not alone here, either, but the combination with #1 starts to weed out other languages.

Elixir is compiled, which means AI tools (and developers) get immediate, structured feedback before your code runs, pointing out exactly what's wrong. Minor bonus, Elixir's Gradual Set-Theoretic Types are closing the gap to static compiled and strongly typed languages. Instead of failing silently at runtime, compilation errors tell you exactly where the problem is‚Äîwhich is just as useful for an AI refactoring code as it is for a human. This keeps the iteration loop for the AI tight and efficient because it will be more likely to make the correct change after an error than receiving a message like `null is not an object`.


## 3. Elixir, Best Tests in the West üëàüëâ


One of Elixir‚Äôs biggest strengths is how deeply its testing framework integrates with real application behavior. This has a caveat, if you are using a frontend framework for a SPA, you lose some of this benefit. Because under Elixir is Erlang running on the BEAM (Bogdan/Bj√∂rn's Erlang Abstract Machine), we can run your entire application as a collection of processes and interact with it from "outside". Side bonus of being able to run most tests concurrently, you have a beautiful feedback loop. I'm using Elixir Liveview and avoid an SPA for now, which means I can also get UI tests that run the whole application, trigger UI events on button clicks or navigation links. I‚Äôve never been a fan of full integration tests‚Äîtoo much setup, maintenance, and still miss things. But now, with AI writing and running them, I‚Äôm rethinking that.

That means AI tools can:

* Interact with the full app‚ÄîAPI, UI, and DB‚Äîin native tests.
* Get structured failures and iterate without manual debugging.
* Build and maintain integration and UI tests.

## AI has changed how I see Elixir

My experience using LLMs with Elixir, most recently Cursor and Claude Code, have been incredible (I want to write about this separately). I can have my agent design the implementation plan, define the tests that we will get passing in a TDD style, build the features, assert against the tests, and perform that loop until the plan is complete. Elixir is not alone in these facets, but the combination is unique. Elixir's core developer experience principles make it a perfect match for AI coding. The documentation and functional style provide an immediate benefit over many languages; exceptional amount of written feedback through compilation and error messages lead to better AI solutions; the speed, quality, and extent of testing (including doctests) means that the AI iteration loops can go faster and further than any other language.

My experience using LLMs with Elixir‚Äîespecially Cursor and Claude Code‚Äîhas been incredible. I will give lots of context on the situation, ask to start by making a `TODO.md` implementation plan that includes the tests in TDD style, and let the agent build features, run the suite, and iterate until it‚Äôs done. Elixir isn‚Äôt the only language with these capabilities, but the combination of clear docs, fast compiler feedback, and integrated testing makes it uniquely effective. It has been a delight to work with it and build enough context for it to navigate my code like a seasoned young engineer.

That‚Äôs not a future I‚Äôm waiting for‚Äîit‚Äôs already here.

I‚Äôm betting on the AI-driven development future. JS and Python devs may have a head start, but I don‚Äôt think they‚Äôre riding the best horse. Elixir has the right DNA‚Äîand our way forward is to create, share, and lead with great code. That‚Äôs something this community excels at. Writing this blog (and sharing more code) is part of that effort.

We have a moment. Let‚Äôs make sure Elixir rises with the AI tide.


{: .note }
To share the credit, if you're working in a statically typed language as well? (_cough: Elm_ üòç) Your compiler is a gold mine for an AI assistant to work with, line numbers, exact type references, even calling out specific function signatures and variables that have the issue :chef-kiss:.