---
layout: post
title:  "Elixir's Advantage in the Era of AI"
date:   2025-03-25 7:00:00 -0500
categories: blog
tags: [elixir, phoenix, liveview, ai, cursor, claude-code]
author: Aaron
author_twitter: shamshirz
image: /assets/elixir-logo.jpeg
---
My experience with AI-assisted coding [![elixir logo]({{ "/assets/elixir-logo.jpeg" | relative_url }}){:class="excerpt-image" style="border-radius: 8px; width: 80px; height: auto;"}](https://elixir-lang.org/) {%- if page.tags -%}{% for tag in page.tags %}<a href="{{site.baseurl}}/archive.html#{{tag | slugize}}">#{{ tag }}</a> {% endfor %}{%- endif -%}
<!-- Ends the excerpt text, it includes the image -->

Iâ€™ve been deep in AI dev tooling for about 10 months, and Iâ€™m now fully bought in on the future of AI-assisted development. Tools like [Cursor](https://www.cursor.com/) and [Claude Code ğŸš€](https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview) are no longer just autocompleteâ€”they can self-iterate. Theyâ€™ll run tests, interpret failures, revise code without my intervention, and do it until everything works.

And the more structured feedback you feed these toolsâ€”errors, types, docs, testsâ€”the better they perform. We want to make each iteration as fast and accurate as possible. Thatâ€™s where Elixir quietly shines.

Despite being a small slice of training data, Elixir is uniquely well-positioned to thrive in this new model. **It has three traits that stack up beautifully for AI pair programming: First-Class Documentation, Functional + Compiled Design, and a Deeply Integrated Testing Model (thanks, BEAM).**

## 1. First-Class Documentation: Context Built into the Code

Elixir treats documentation as a first-class citizen. Every function and module has structured, built-in documentation next to the code. Itâ€™s not just scattered commentsâ€”itâ€™s compiled, queryable, and often includes real usage examples through `doctests`. That can be run and updated by our AI!

This is a goldmine for LLMs. Instead of guessing how a function works, AI tools can read structured descriptions, see example inputs/outputs, and even run the embedded tests. This means fewer hallucinations, better API usage, and more accurate code. Elixir isnâ€™t alone in great doc support, but it compounds the benefits with these other features.

## 2. Functional & Compiled: Predictable, Debuggable, and AI-Friendly

Grouping these may be cheating, but any functional, compiled language has an edge for AI. Functional code is more straightforward for people to reason about because you should only need the context of the function you are in. No side effects on variables outside the scope, no class variables to chase down, and the AI's context window thanks you. Elixir is not alone here, either, but the combination with #1 narrows the field significantly

Elixir is compiled, which means AI tools (and developers) get immediate, structured feedback before your code runs, pointing out exactly what's wrong. As a minor bonus, Elixir's [Gradual Set-Theoretic Types]("https://hexdocs.pm/elixir/gradual-set-theoretic-types.html") are closing the gap to static compiled and strongly typed languages. Instead of failing silently at runtime, compilation errors tell you exactly where the problem isâ€”which is as helpful for an AI refactoring code as it is for a human. This keeps the iteration loop for the AI tight and efficient because it will be more likely to make the correct change after an error than to receive a message like `null is not an object.`


## 3. Elixir, Best Tests in the West ğŸ‘ˆğŸ¤ ğŸ‘‰


One of Elixirâ€™s biggest strengths is how deeply its testing framework integrates with real application behavior. This has a caveat, if you are using a frontend framework for an SPA, you lose some of this benefit. Because Elixir is Erlang running on the [BEAM (Bogdan/BjÃ¶rn's Erlang Abstract Machine)](https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)), we can run your entire application as a collection of processes and interact with it from "outside." The side bonus of being able to run most tests concurrently is a spooky fast feedback loop. I'm using [Phoenix Liveview]("https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html") and avoiding an SPA for now, which means I can also get UI tests that run the whole application, and trigger UI events on button clicks or navigation links. Iâ€™ve never been a fan of full integration testsâ€”too much setup and maintenance, and they still miss things. But now, the cost has gone down with AI writing and maintaining tests while the value has gone up because the same AI can benefit from the feedback that used to require manual aid.

That means AI tools can:

* Interact with the full appâ€”API, UI, and DBâ€”in native tests.
* Get structured failures and iterate without manual debugging.
* Build and maintain integration and UI tests.

## AI has changed how I see Elixir

My experience using LLMs with Elixirâ€”especially Cursor and Claude Codeâ€”has been incredible. I will give lots of context on the situation, ask to start by making a `TODO.md` implementation plan that includes the tests in TDD style, and let the agent build features, run the suite, and iterate until itâ€™s done. Elixir isnâ€™t the only language with these capabilities, but the combination of clear docs, fast compiler feedback, and integrated testing makes it uniquely effective. It has been a delight to work with it and build enough context for it to navigate my code like a seasoned young engineer.

Thatâ€™s not a future Iâ€™m waiting forâ€”itâ€™s already here.

Iâ€™m betting on the future of AI-driven development. JS and Python devs may have a head start, but I donâ€™t think they ride the best horse. Elixir has the right DNAâ€”and our way forward is to create, share, and lead with great code. Thatâ€™s something this community excels at. Writing this blog (and sharing more code) is part of that effort.

We have a moment. Letâ€™s make sure Elixir rises with the AI tide.


{: .note }
To share the credit, if you're working in a statically typed language as well as function? (_cough: Elm_ ğŸ˜) Then your compiler is a gold mine for an AI assistant to work with, line numbers, exact type references, even calling out specific function signatures and variables that have the issue :chef-kiss:.

TY to [RJ Dellecese](https://github.com/rjdellecese) for editing.